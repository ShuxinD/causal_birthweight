else {
vintage <- vintage
}
if(benchmark == "Public_AR_Current"){
benchmark <- 4
}else if(benchmark == "Public_AR_Census2010"){
benchmark <- 9
}
if(vintage == "Census2010_Current"){
vintage <- 410
}else if(vintage == "Census2000_Census2010"){
vintage <- 900
}
call_start <- "https://geocoding.geo.census.gov/geocoder/geographies/coordinates?"
url <- paste0("x=", lon, "&y=", lat)
benchmark0 <- paste0("&benchmark=", benchmark)
vintage0 <- paste0("&vintage=", vintage, "&format=json")
url_full <- paste0(call_start, url, benchmark0, vintage0)
r <- httr::GET(url_full)
httr::stop_for_status(r)
response <- httr::content(r)
if (length(response$result$geographies$`Census Tracts`[[1]]$GEOID) ==
0) {
message(paste0("Lat/lon (", lat, ", ", lon, ") returned no geocodes. An NA was returned."))
return(NA_character_)
}
else {
if (length(response$result$geographies$`Census Tracts`[[1]]$GEOID) >
1) {
message(paste0("Lat/lon (", lat, ", ", lon, ") returned more than geocode. The first match was returned."))
}
return(response$result$geographies$`Census Tracts`[[1]]$GEOID)
}
}
############################# 2. get tract #####################################
## make it parallel
cl <- makeCluster(n_cores, type="FORK")
registerDoParallel(cl)
start_time <- Sys.time()
foreach(i = 1:nrow(birth), .combine = c, .packages = "data.table") %dopar% {
get_geoid_latlon(lat = birth[i, 'lat'], lon = birth[i, 'long'],
benchmark = "Public_AR_Current",
vintage = "Census2010_Current")
# tract_2000 <- get_geoid_latlon(lat = birth[i,'lat'],
#                                            lon = birth[i,'long'],
#                                            benchmark = "Public_AR_Census2010",
#                                            vintage = "Census2000_Census2010")
}
tract2010 <- foreach(i = 1:nrow(birth), .combine = c, .packages = "data.table") %dopar% {
get_geoid_latlon(lat = birth[i, 'lat'], lon = birth[i, 'long'],
benchmark = "Public_AR_Current",
vintage = "Census2010_Current")
# tract_2000 <- get_geoid_latlon(lat = birth[i,'lat'],
#                                            lon = birth[i,'long'],
#                                            benchmark = "Public_AR_Census2010",
#                                            vintage = "Census2000_Census2010")
}
stopCluster(cl)
###############################################################################
# Project: Causal black carbon on birth weight in MA                          #
# Code: GBM to estimate GPS with balance stopping rule                        #
# Code : (GBM example) from three non-overlapping periods                     #
# Input: mabirths_02NOV18.csv (from Anna)                                     #
# Output: ? one dataset with new tract info                                   #
# Author: Shuxin Dong                                                         #
# Date: Oct 21, 2020                                                          #
###############################################################################
############################# 0. Setup ########################################
rm(list = ls())
gc()
library(data.table)
library(doParallel)
library(foreach)
# source("get_geoid_functions.R")
# n_cores <- detectCores()-1
n_cores <- 3
dir_input <- "/Users/shuxind/Desktop/BC_birthweight_data/"
# dir_input <- "/nfs/home/S/shd968/shared_space/ci3_shd968_proj/"
# dir_output <- "/nfs/home/S/shd968/shared_space/ci3_shd968_proj/"
## load data
birth <- fread(file = paste0(dir_input, "mabirths_02NOV18.csv"))
birth <- birth[,.(uniqueid_yr, year, long, lat)]
birth <- na.omit(birth)
birth <- birth[,.SD[sample(.N, min(.N, floor(0.0001*dim(birth)[1])))]] # 0.01% sample
############################# 2. tract function ################################
## benchmark as current to get 2010 census tract
## benchmark as 2010 to get 2000 census tract
## the 'get_geoid_latlon' function is to get the corresponding census tract
get_geoid_latlon <- function (lat, lon, benchmark, vintage) {
if (missing(benchmark)) {
benchmark <- "Public_AR_Current"
}
else {
benchmark <- benchmark
}
if (missing(vintage)) {
vintage <- "Census2010_Current"
}
else {
vintage <- vintage
}
if(benchmark == "Public_AR_Current"){
benchmark <- 4
}else if(benchmark == "Public_AR_Census2010"){
benchmark <- 9
}
if(vintage == "Census2010_Current"){
vintage <- 410
}else if(vintage == "Census2000_Census2010"){
vintage <- 900
}
call_start <- "https://geocoding.geo.census.gov/geocoder/geographies/coordinates?"
url <- paste0("x=", lon, "&y=", lat)
benchmark0 <- paste0("&benchmark=", benchmark)
vintage0 <- paste0("&vintage=", vintage, "&format=json")
url_full <- paste0(call_start, url, benchmark0, vintage0)
r <- httr::GET(url_full)
httr::stop_for_status(r)
response <- httr::content(r)
if (length(response$result$geographies$`Census Tracts`[[1]]$GEOID) ==
0) {
message(paste0("Lat/lon (", lat, ", ", lon, ") returned no geocodes. An NA was returned."))
return(NA_character_)
}
else {
if (length(response$result$geographies$`Census Tracts`[[1]]$GEOID) >
1) {
message(paste0("Lat/lon (", lat, ", ", lon, ") returned more than geocode. The first match was returned."))
}
return(response$result$geographies$`Census Tracts`[[1]]$GEOID)
}
}
############################# 2. get tract #####################################
## make it parallel
cl <- makeCluster(n_cores, type="FORK")
registerDoParallel(cl)
start_time <- Sys.time()
tract2010 <- foreach(i = 1:nrow(birth), .combine = c, .packages = "data.table") %dopar% {
get_geoid_latlon(lat = birth[i, 'lat'], lon = birth[i, 'long'],
benchmark = "Public_AR_Current",
vintage = "Census2010_Current")
}
tract_2000 <- foreach(i = 1:row(birth), .combine = c, .packages = "data.table") %dopar% {
get_geoid_latlon(lat = birth[i,'lat'],
lon = birth[i,'long'],
benchmark = "Public_AR_Census2010",
vintage = "Census2000_Census2010")
}
end_time <- Sys.time()
time <- end_time - start_time
print(time)
stopCluster(cl)
###############################################################################
# Project: Causal black carbon on birth weight in MA                          #
# Code: GBM to estimate GPS with balance stopping rule                        #
# Code : (GBM example) from three non-overlapping periods                     #
# Input: mabirths_02NOV18.csv (from Anna)                                     #
# Output: ? one dataset with new tract info                                   #
# Author: Shuxin Dong                                                         #
# Date: Oct 21, 2020                                                          #
###############################################################################
############################# 0. Setup ########################################
rm(list = ls())
gc()
library(data.table)
library(doParallel)
library(foreach)
# source("get_geoid_functions.R")
# n_cores <- detectCores()-1
n_cores <- 3
dir_input <- "/Users/shuxind/Desktop/BC_birthweight_data/"
# dir_input <- "/nfs/home/S/shd968/shared_space/ci3_shd968_proj/"
# dir_output <- "/nfs/home/S/shd968/shared_space/ci3_shd968_proj/"
## load data
birth <- fread(file = paste0(dir_input, "mabirths_02NOV18.csv"))
birth <- birth[,.(uniqueid_yr, year, long, lat)]
birth <- na.omit(birth)
birth <- birth[,.SD[sample(.N, min(.N, floor(0.0001*dim(birth)[1])))]] # 0.01% sample
############################# 2. tract function ################################
## benchmark as current to get 2010 census tract
## benchmark as 2010 to get 2000 census tract
## the 'get_geoid_latlon' function is to get the corresponding census tract
get_geoid_latlon <- function (lat, lon, benchmark, vintage) {
if (missing(benchmark)) {
benchmark <- "Public_AR_Current"
}
else {
benchmark <- benchmark
}
if (missing(vintage)) {
vintage <- "Census2010_Current"
}
else {
vintage <- vintage
}
if(benchmark == "Public_AR_Current"){
benchmark <- 4
}else if(benchmark == "Public_AR_Census2010"){
benchmark <- 9
}
if(vintage == "Census2010_Current"){
vintage <- 410
}else if(vintage == "Census2000_Census2010"){
vintage <- 900
}
call_start <- "https://geocoding.geo.census.gov/geocoder/geographies/coordinates?"
url <- paste0("x=", lon, "&y=", lat)
benchmark0 <- paste0("&benchmark=", benchmark)
vintage0 <- paste0("&vintage=", vintage, "&format=json")
url_full <- paste0(call_start, url, benchmark0, vintage0)
r <- httr::GET(url_full)
httr::stop_for_status(r)
response <- httr::content(r)
if (length(response$result$geographies$`Census Tracts`[[1]]$GEOID) ==
0) {
message(paste0("Lat/lon (", lat, ", ", lon, ") returned no geocodes. An NA was returned."))
return(NA_character_)
}
else {
if (length(response$result$geographies$`Census Tracts`[[1]]$GEOID) >
1) {
message(paste0("Lat/lon (", lat, ", ", lon, ") returned more than geocode. The first match was returned."))
}
return(response$result$geographies$`Census Tracts`[[1]]$GEOID)
}
}
############################# 2. get tract #####################################
## make it parallel
cl <- makeCluster(n_cores, type="FORK")
registerDoParallel(cl)
start_time <- Sys.time()
tract2010 <- foreach(i = 1:nrow(birth), .combine = c, .packages = "data.table") %dopar% {
get_geoid_latlon(lat = birth[i, 'lat'], lon = birth[i, 'long'],
benchmark = "Public_AR_Current",
vintage = "Census2010_Current")
}
tract2000 <- foreach(i = 1:nrow(birth), .combine = c, .packages = "data.table") %dopar% {
get_geoid_latlon(lat = birth[i,'lat'],
lon = birth[i,'long'],
benchmark = "Public_AR_Census2010",
vintage = "Census2000_Census2010")
}
end_time <- Sys.time()
time <- end_time - start_time
print(time)
stopCluster(cl)
library(logNormReg)
install.packages("logNormReg")
library(logNormReg)
rm(list=ls())
n=200
s=.4
set.seed(1234)      #just to get reproducible results..
x<-seq(.1,10,l=n) #covariate
mu<- 10+2*x  #linear regression function
y<-rlnorm(n, log(mu)-s^2/2, s) #data..
o0<-lm(log(y)~x) #the usual but WRONG model
o<- lognlm(y~x) #fit the 'right' model
plot(x,y)
lines(x, mu, lwd=2)
points(x, exp(fitted(o0)), col=2, type="l", lwd=2)
points(x, fitted(o), col=3, type="l", lwd=2)
legend("topleft", legend=c("true", "lm(log(y)~x)", "lognlm(y~x)"),
col=c(1,2,3), lwd=2)
#Sometimes people would estimate parameters by minimizing a least square objective
# (i.e. by setting 'lik=FALSE', see Details), wherein data would come from
# Y = mu * exp(eps) where eps~N(0,s)..
y1<-mu*exp(rnorm(n,0,1)) #data..
o1<-lognlm(y1~x, lik=FALSE) #set 'lik=FALSE', see Details
############################# 0. Setup ########################################
rm(list = ls())
gc()
library(data.table)
library(doParallel)
library(foreach)
# source("get_geoid_functions.R")
# n_cores <- detectCores()-1
n_cores <- 3
dir_input <- "/Users/shuxind/Desktop/BC_birthweight_data/"
## load data
birth <- fread(file = paste0(dir_input, "mabirths_02NOV18.csv"))
birth <- birth[,.(uniqueid_yr, year, long, lat)]
birth <- na.omit(birth)
birth <- birth[,.SD[sample(.N, min(.N, floor(0.0001*dim(birth)[1])))]] # 0.01% sample
system.time(for (i in 1:nrow(birth)){
get_geoid_latlon(lat = birth[i,'lat'],
lon = birth[i,'long'],
benchmark = "Public_AR_Census2010",
vintage = "Census2000_Census2010")
})
############################# 2. tract function ################################
## benchmark as current to get 2010 census tract
## benchmark as 2010 to get 2000 census tract
## the 'get_geoid_latlon' function is to get the corresponding census tract
get_geoid_latlon <- function (lat, lon, benchmark, vintage) {
if (missing(benchmark)) {
benchmark <- "Public_AR_Current"
}
else {
benchmark <- benchmark
}
if (missing(vintage)) {
vintage <- "Census2010_Current"
}
else {
vintage <- vintage
}
if(benchmark == "Public_AR_Current"){
benchmark <- 4
}else if(benchmark == "Public_AR_Census2010"){
benchmark <- 9
}
if(vintage == "Census2010_Current"){
vintage <- 410
}else if(vintage == "Census2000_Census2010"){
vintage <- 900
}
call_start <- "https://geocoding.geo.census.gov/geocoder/geographies/coordinates?"
url <- paste0("x=", lon, "&y=", lat)
benchmark0 <- paste0("&benchmark=", benchmark)
vintage0 <- paste0("&vintage=", vintage, "&format=json")
url_full <- paste0(call_start, url, benchmark0, vintage0)
r <- httr::GET(url_full)
httr::stop_for_status(r)
response <- httr::content(r)
if (length(response$result$geographies$`Census Tracts`[[1]]$GEOID) ==
0) {
message(paste0("Lat/lon (", lat, ", ", lon, ") returned no geocodes. An NA was returned."))
return(NA_character_)
}
else {
if (length(response$result$geographies$`Census Tracts`[[1]]$GEOID) >
1) {
message(paste0("Lat/lon (", lat, ", ", lon, ") returned more than geocode. The first match was returned."))
}
return(response$result$geographies$`Census Tracts`[[1]]$GEOID)
}
}
system.time(for (i in 1:nrow(birth)){
get_geoid_latlon(lat = birth[i,'lat'],
lon = birth[i,'long'],
benchmark = "Public_AR_Census2010",
vintage = "Census2000_Census2010")
})
stopCluster(cl)
quit
quit()
############################# 0. Setup ########################################
rm(list = ls())
gc()
library(dplyr)
library(h2o)
library(data.table)
dir_input <- "/Users/shuxind/Desktop/BC_birthweight_data/"
## load data
birth <- fread(paste0(dir_input, "birth_final.csv"))
## load data
birth <- fread(paste0(dir_input, "birth_final.csv"),
drop = "V1")
birth <- sample_n(birth, floor(0.001*dim(birth)[1])) # sample as an example
############################# 1. data manipulation ############################
var <- c("year","sex","married","mage","mrace","m_edu", "cigdpp","cigddp",
"clinega","kotck","pncgov", "bwg", "rf_db_gest","rf_db_other",
"rf_hbp_chronic", "rf_hbp_pregn","rf_cervix","rf_prev_4kg",
"rf_prev_sga", "bc_30d","bc_3090d", "bc_90280d", "parit_cat","m_wg_cat",
"log_mhincome", "log_mhvalue", "percentPoverty")
birth <- birth[ , var, with = F]
############################# 1. data manipulation ############################
var <- c("year","sex","married","mage","mrace","m_edu", "cigdpp","cigddp",
"clinega","kotck","pncgov", "bwg", "rf_db_gest","rf_db_other",
"rf_hbp_chronic", "rf_hbp_pregn","rf_cervix","rf_prev_4kg",
"rf_prev_sga", "bc_30d","bc_3090d", "bc_90280d", "firstborn","m_wg_cat",
"log_mhincome", "log_mhvalue", "percentPoverty")
birth <- birth[ , var, with = F]
############################# 0. Setup ########################################
rm(list = ls())
gc()
library(dplyr)
library(h2o)
library(data.table)
dir_input <- "/Users/shuxind/Desktop/BC_birthweight_data/"
## load data
birth <- fread(paste0(dir_input, "birth_final.csv"),
drop = "V1")
birth <- sample_n(birth, floor(0.001*dim(birth)[1])) # sample as an example
############################# 1. data manipulation ############################
var <- c("year","sex","married","mage","mrace","m_edu", "cigdpp","cigddp",
"clinega","kotck","pncgov", "bwg", "rf_db_gest","rf_db_other",
"rf_hbp_chronic", "rf_hbp_pregn","rf_cervix","rf_prev_4kg",
"rf_prev_sga", "bc_30d","bc_3090d", "bc_90280d", "firstborn","m_wg_cat",
"log_mhincome", "log_mhvalue", "percentPoverty")
birth <- birth[ , var, with = F]
############################# 0. Setup ########################################
rm(list = ls())
gc()
library(dplyr)
library(h2o)
library(data.table)
dir_input <- "/Users/shuxind/Desktop/BC_birthweight_data/"
# dir_input <- "/nfs/home/S/shd968/shared_space/ci3_shd968_proj/"
## load data
birth <- fread(paste0(dir_input, "birth_final.csv"),
drop = "V1")
birth <- sample_n(birth, floor(0.001*dim(birth)[1])) # sample as an example
## set hyperparameter
n.trees <- 20000
max.depth <- 8
min.rows <- 10
############################# 2. data manipulation ############################
var <- c("year","sex","married","mage","mrace","m_edu", "cigdpp","cigddp",
"clinega","kotck","pncgov", "bwg", "rf_db_gest","rf_db_other",
"rf_hbp_chronic", "rf_hbp_pregn","rf_cervix","rf_prev_4kg",
"rf_prev_sga", "bc_30d","bc_3090d", "bc_90280d", "firstborn","m_wg_cat",
"log_mhincome", "log_mhvalue", "percentPoverty")
birth <- birth[ , var, with = F]
birth[, T := bc_30d]
birth.hex <- as.h2o(birth, destination_frame = "birth.hex")
############################## 2. do h2o.gbm ###################################
# h2o.init(nthreads = -1)
h2o.init(nthreads = 1) # sample
birth.hex <- as.h2o(birth, destination_frame = "birth.hex")
gbm_30d <- h2o.gbm(y = T,
x = independent,
training_frame = birth.hex,
ntrees = n.trees,
max_depth = max.depth,
min_rows = min.rows,
learn_rate = 0.0005, # may change later
distribution = "gaussian")
## fit the propensity score model, don't use the response variable in fitting model
independent <- c("year", "sex", "married", "mage", "mrace", "m_edu",
"cigdpp", "cigddp", "clinega", "kotck", "pncgov",
"rf_db_gest", "rf_db_other", "rf_hbp_chronic",
"rf_hbp_pregn", "rf_cervix", "rf_prev_4kg", "rf_prev_sga",
"parit_cat", "m_wg_cat", "log_med_hs_inc",
"bc_3090d", "bc_90280d")
gbm_30d <- h2o.gbm(y = T,
x = independent,
training_frame = birth.hex,
ntrees = n.trees,
max_depth = max.depth,
min_rows = min.rows,
learn_rate = 0.0005, # may change later
distribution = "gaussian")
gbm_30d <- h2o.gbm(y = "T",
x = independent,
training_frame = birth.hex,
ntrees = n.trees,
max_depth = max.depth,
min_rows = min.rows,
learn_rate = 0.0005, # may change later
distribution = "gaussian")
?h2o.init
h2o.shutdown()
############################# 0. Setup ########################################
rm(list = ls())
gc()
library(dplyr)
library(h2o)
library(data.table)
dir_input <- "/Users/shuxind/Desktop/BC_birthweight_data/"
## load data
birth <- fread(paste0(dir_input, "birth_final.csv"),
drop = "V1")
birth$year <- as.factor(birth$year)
birth$mrace <- as.factor(birth$mrace)
birth$m_edu <- as.factor(birth$m_edu)
birth$kotck <- as.factor(birth$kotck)
birth$m_wg_cat <- as.factor(birth$m_wg_cat)
birth <- sample_n(birth, floor(0.001*dim(birth)[1])) # sample as an example
## set hyperparameter
n.trees <- 20000
max.depth <- 8
min.rows <- 10
############################# 2. data manipulation ############################
var <- c("year","sex","married","mage","mrace","m_edu", "cigdpp","cigddp",
"clinega","kotck","pncgov", "bwg", "rf_db_gest","rf_db_other",
"rf_hbp_chronic", "rf_hbp_pregn","rf_cervix","rf_prev_4kg",
"rf_prev_sga", "bc_30d","bc_3090d", "bc_90280d", "firstborn","m_wg_cat",
"log_mhincome", "log_mhvalue", "percentPoverty")
birth <- birth[ , var, with = F]
############################## 2. do h2o.gbm ###################################
# h2o.init(nthreads = -1)
h2o.init(nthreads = 1) # sample
birth[, T := bc_30d]
birth.hex <- as.h2o(birth, destination_frame = "birth.hex")
## fit the propensity score model, don't use the response variable in fitting model
independent <- c("year","sex","married","mage","mrace","m_edu", "cigdpp","cigddp",
"clinega","kotck","pncgov", "bwg", "rf_db_gest","rf_db_other",
"rf_hbp_chronic", "rf_hbp_pregn","rf_cervix","rf_prev_4kg",
"rf_prev_sga","firstborn","m_wg_cat",
"log_mhincome", "log_mhvalue", "percentPoverty",
"bc_3090d", "bc_90280d")
gbm_30d <- h2o.gbm(y = "T",
x = independent,
training_frame = birth.hex,
ntrees = n.trees,
max_depth = max.depth,
min_rows = min.rows,
learn_rate = 0.0005, # may change later
distribution = "gaussian")
?h2o.predict
pred <- h2o.predict(object = gbm_30d, newdata = birth.hex)
pred
birth.hex
as.data.frame(pred)
hh <- as.data.frame(pred)
hh <- as.vector(pred)
h2o.shutdown()
model.num = lm(T~1, data = birth)
summary(model.num)
ps.num <- dnorm((birth$T-model.num$fitted)/(summary(model.num))$sigma,0,1)
